(* ::Package:: *)

BeginPackage[ "generatingPoints`"]
 
 Needs["rotation`"] ; 
 
 Needs["IntersectionChecking`"]; 

  lineFunction3D::usage = 
	"Parametric equation for a line in 3d that goes in the direction v and through the point p. Returns the (x,y,z) value at the atpoint t. "

  DiscretizeLineOfIntersection::usage = 
	"Input: 2 Points in 3D and length h. Output: Discrete points along the line between the 2 endpoints with uniform spacing approximaently length h "

  CreateIntersectionPoints::usage = 
	"Discretizes the Line of Intersection between all the polygons"

  calculateNumberOfLineElements::usage = 
	"Input the points generated by CreateIntersectionPoints. Calculated the number of line segments between the points, Output Number of line elements   "

  CreatePolygonPoints::usage  = 
	"Rotates all the vertices of the polygons into a X,Y plane. Returns an array of all vertices tagged with poly numbers"

  SampleFisher::usage  = 
	"Generates samples from von Mises-Fisher distribution" 

  CheckIntersectionPoint::uage = 
    "Checks the distance between intersection point and polygon's edges"

  Begin[ "private`"]

  lineFunction3D[vector_,point_, t0_] :=Block[{ v = vector, p = point, t = t0 , pt},
	pt = {0,0,0};
	pt[[1]] = p[[1]] + v[[1]]*t;
	pt[[2]] = p[[2]] + v[[2]]*t;
	pt[[3]] = p[[3]] + v[[3]]*t;
	pt
 ]

DiscretizeLineOfIntersection[endpoints_, hscale_] := Block[ {endpts = endpoints, h = hscale, x0,y0,z0,x1,y1,z1,v,p, dist, nprime, hprime, xx, newPoints,i, tmp},
		x0 = endpts[[1,1]];
		y0 = endpts[[1,2]];
		z0 = endpts[[1,3]];

		x1 = endpts[[2,1]];
		y1 = endpts[[2,2]];
		z1 = endpts[[2,3]];
		v = {x1 - x0, y1 - y0, z1 - z0};
		p = {x0,y0,z0};

		dist = EuclideanDistance[{x0,y0,z0}, {x1,y1,z1}];
		nprime = Ceiling[2*dist/h];
	    hprime = 1/nprime;
		xx = Range[0,1,hprime];

 		newPoints = FlattenAt[{endpts[[1]], Table[lineFunction3D[v,p,xx[[i]]],{i,nprime}], endpts[[2]]},2 ];
														   
	newPoints = DeleteDuplicates[newPoints];
	newPoints
]

CreateIntersectionPoints[matrix_, array_, hscale_, eps_] :=Block[ {A = matrix, poly = array, h = hscale, nPoly, ii, jj, i, endPoints, 
 intersectionPoints, tmpPoints, tmpPointsNew,tmpPoly, tmpPolyInt,ip, np, ipn, ipni,lengthNew, intcount, newIndexL, newIndexF},

	nPoly = Length[poly];
    
	intersectionPoints = Reap[ 
	For[ ii = 1, ii <= nPoly, ii++,
         
       intcount=0;
		For[jj = 1, jj <= A[[ii,1]], jj++,
				endPoints = ConstantArray[{0,0,0}, 2];
				
				endPoints[[1]] = A[[ii,2,jj,2]] ;
				endPoints[[2]] = A[[ii,2,jj,3]] ;
          
				(*Discretize Line of Intersection*)
				tmpPoints = DiscretizeLineOfIntersection[endPoints, h];
              lengthNew=0;
              np=Length[tmpPoints];
             
              tmpPointsNew = ConstantArray[{0,0,0},np];
              tmpPoly = poly[[ii]]; 
              tmpPolyInt= poly[[A[[ii,2,jj,1]]]];
   
          newIndexF=0;
           For[ ip = 2, ip <= np-1 ,ip++,  
               
                ipn=CheckIntersectionPoint[tmpPoly, tmpPoints[[ip]],h, eps];
                ipni=CheckIntersectionPoint[tmpPolyInt, tmpPoints[[ip]],  h, eps];
                If[ ipn == tmpPoly[[1,2]] && ipni==tmpPolyInt[[1,2]] , 
                 newIndexF=ip;
                  Break[]]
                 ];
              newIndexL=0;
             For[ ip = np-1, ip >= 2 ,ip--,  
               
                ipn=CheckIntersectionPoint[tmpPoly, tmpPoints[[ip]],h, eps];
                ipni=CheckIntersectionPoint[tmpPolyInt, tmpPoints[[ip]],  h, eps];
               If[ ipn == tmpPoly[[1,2]] && ipni==tmpPolyInt[[1,2]] , newIndexL=ip; 
               Break[]]
                ];
          If[newIndexF==2, newIndexF=1]; 
          If[newIndexL==np-1, newIndexL=np];
              For [ip=newIndexF, ip <=newIndexL, ip++,
                   lengthNew++;
                   tmpPointsNew[[lengthNew]]=tmpPoints[[ip]]];
     (*exclude very short intersections*)
		    If[lengthNew < 2, Print["small intersection ",ii]; 
               intcount++,
          (*
             (* Rotate Points*)
				tmpPoints = rotatePoints[ tmpPoints, poly[[ii,2,1]], eps];
				(*Tag Points with poly ii and jj*)
         
				Sow[Table[{tmpPoints[[i]],{ii,A[[ii,2,jj,1]]}},{i,np}] ], 
 
                 *) 
             (* Rotate Points*)
				tmpPointsNew = rotatePoints[ tmpPointsNew, poly[[ii,2,1]], eps];
				(*Tag Points with poly ii and jj*)
         
				Sow[Table[{tmpPointsNew[[i]],{ii,A[[ii,2,jj,1]]}},{i,lengthNew}] ]
         
				(* AppendTo[intersectionPoints, Table[{tmpPoints[[i]],{ii,A[[ii,2,jj,1]]}},{i,Length[tmpPoints]}] ] *)
                ] 


	         ]; (* end of loop on intersections (jj) in polygon ii *)
           If[intcount==A[[ii,1]],Print["no intersections ", ii, " ",intcount, " ",np]]
	] (* end of loop on polygons (ii) *)
	
	]; (* end of Reap*)
(* intersectionPoints = Flatten[intersectionPoints,1]; *)
intersectionPoints = Flatten[intersectionPoints[[2,1]],1]; 

(* If[intersectionPoints!=intersectionPoints, Print[intersectionPoints]; Print["---"]; Print[intersectionPoints] ]; *)

intersectionPoints
];

CheckIntersectionPoint[array_ , intpoint_, hscale_,  eps_]:= Block[{tmpPoly = array, tmpPoint = intpoint, h=hscale,
 es=eps, kk, next, edge, dist1, ip = i, ipnn},
                      ipnn=0;
 (* Next loop checks the distance between current point of intersection to all the edges of first polygon*)
			For[ kk = 1, kk <= tmpPoly[[1,2]], kk++, 
				If[ kk == tmpPoly[[1,2]], next = 1, next = kk+1 ];
				edge = {tmpPoly[[3,kk]],tmpPoly[[3,next]]};
                dist1 = pointToLineSeg[tmpPoint,edge]; (* find distance  point of the intersection and an edge *)
			
            If[dist1<(h*0.35) && dist1>es, 
                        ipnn=0;
                         Break[],     
                          ipnn++
                               ]
           
                  ]; 

ipnn
];

calculateNumberOfLineElements[array_] := Block[{linePoints = array, elemCnt, i},

	elemCnt = 0;
	For[i = 1, i < Length[linePoints], i++,
		If[ linePoints[[i,2,1]] == linePoints[[i+1,2,1]] && linePoints[[i,2,2]] == linePoints[[i+1,2,2]], 
		elemCnt++;
		];
	];
elemCnt
];





CreatePolygonPoints[array_, eps_] := Block[{poly = array, nPoly, nNodes, tmp, i, j,polyPoints, dist},
	nPoly = Length[poly];
	(*Rotate the polygons into the XY Plane*)
  {r,{polyPoints}} = Reap[
	For[ i = 1, i <= nPoly , i++,
		nNodes = poly[[i,1,2]];
		tmp = ConstantArray[{0,0,0},nNodes];
		For [j= 1, j <= nNodes, j++,
			tmp[[j]] =  poly[[i,3,j]] 
    
		];
		tmp = rotatePoints[tmp, poly[[i,2,1]], eps];
		For[j=1,j<=nNodes,j++,
      
			Sow[{tmp[[j]],i}]
		]
	];
  ];

polyPoints
];

SampleFisher[ theta0_,  phi0_, kappa_] := Block[ {v,   u , M,    ck = (Exp[kappa] - Exp[-kappa])/kappa, theta, V, y, w}, 
 (* rotation vector for later use *) 
  v = N[{Sin[theta0] Cos[phi0], Sin[theta0] Sin[phi0], Cos[theta0]}] ; 
 u = {0, 0, 1}; 
M = RotationMatrix[{u, v}];  
   theta = RandomReal[ {0, 2 Pi}]; 
   V = {Cos[theta], Sin[theta]}; 
   y = Random[]; 
   w = 1/kappa * Log[ Exp[-kappa] + kappa ck y];  
   M. Append[Sqrt[1 - w^2] V, w] 
]; 


  End[]

  EndPackage[]


